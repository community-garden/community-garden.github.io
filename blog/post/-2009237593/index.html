<!DOCTYPE html><html lang="en"><head><meta name="generator" content="React Static"/><title data-react-helmet="true">Pergola | Frameworks &amp; Technologien</title><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/><link rel="preload" as="script" href="/templates/vendors~__react_static_root__/src/containers/Markdown~__react_static_root__/src/containers/Post~__re~b073af23.45cfb8c8.js"/><link rel="preload" as="script" href="/templates/__react_static_root__/src/containers/Post.295a4ca4.js"/><link rel="preload" as="script" href="/templates/styles.76a77108.js"/><link rel="preload" as="script" href="/templates/vendors~main.4c21852a.js"/><link rel="preload" as="script" href="/main.2c295d01.js"/><link rel="preload" as="style" href="/styles.33a941e7.css"/><link rel="stylesheet" href="/styles.33a941e7.css"/></head><body><div id="root"><div style="outline:none" tabindex="-1"><div class="fresnel-container fresnel-greaterThan-mobile "><div><div style="background-image:url(&quot;/jtilsch_06_2021_garden_q60.JPG&quot;);background-size:cover;background-position:top -100px center;padding:1rem 0 3rem" class="ui inverted vertical center aligned segment"><div class="ui large inverted pointing secondary menu"><div class="ui container"><a class="item" href="/">Project</a><a class="item" href="/blog">Blog</a><a class="item" href="/milestones">Milestones</a><a class="item" href="/team">Team</a></div></div><div class="ui text container"><h1 style="font-size:3rem;font-weight:normal;margin-bottom:0;margin-top:2rem" class="ui inverted header">Community Garden App</h1><h2 style="font-size:1.7rem;font-weight:normal;margin-top:1.5rem" class="ui inverted header">organize, manage, connect to local gardening initiatives</h2><button style="display:none" class="ui huge primary button">Get the App<i aria-hidden="true" class="right arrow icon"></i></button></div></div></div><div style="padding:4rem 0" class="ui vertical segment"><div class="ui text container"><div style="outline:none" tabindex="-1"><div class="blog"><a href="/blog/">&lt;<!-- --> Back</a><br/><h2>Frameworks &amp; Technologien</h2><h2>Platform</h2><ul><li>Desktop Browser (Fireforx + Chrome + Safari)</li><li>Desktop Electron (Cordov mit WebKit)</li><li>Desktop PWA (Firefox + Chrome)</li><li>mobil (iOS + Android) PWA (Firefox + Chrome)</li><li>mobil (iOS + Android)  almost nativ (Cordova mit WebKit)</li></ul><h2>Full-Stack</h2><p>Als Full-Stack bezeichnet man Frameworks, die einem ein fertigen Rahmen für die Client- und Serverentwicklung geben. Es ist nicht unbedingt notwendig ein FullStck Framework zu verwenden aber es kann mitunter die inertiale Entwicklung beschleunigen.</p><ul><li><a href="http://vulcanjs.org/">Vulcan.js</a></li><li><a href="https://www.meteor.com">Meteor</a></li><li><a href="https://fulcro.fulcrologic.com">Fulcro</a></li><li><a href="https://grandstack.io/">GRANDStack</a> - Neo4J, GraphQL, React, Apollo</li></ul><h2>UI</h2><p>Generell bietet es sich an ein modernes UI-Framework zu verwenden. Man profitiert von vielen bereits vorhandnenen Komponenten und kann außerdem auf bewährte Design-patterns (nicht Design im Sinn von Ausssehen sondern im Sinne der Strukturierung von Code) zurückgreifen. Im Web und App-Entwicklungsuniversum haben sich das funktionale Komponentenbasierte React-Framework bewährt, alternativen dazu wären Angular.JS oder WebComponents. Es gibt auch die Möglichkeit Platform native Komponenten zu nutzen, das schließt dann aber die Entwicklung von gleichzeitig einer Web-Anwendung aus. Auch die Platform-Übergreifende Entwicklung ist dann nicht möglich.</p><ul><li>React</li><li>React-Native</li><li>Reframe</li></ul><h4>UI Komponenten Sammlung</h4><p>Neben der UI-Technologie gibt es noch die eigentlichen fertigen Komponenten
auf die man um eines einheitlichen und komfortablen Designs wegen zurückgreifen
kann. Wir ersparen uns dadurch nicht nur arbeit, es ist dann auch gewährleistet, dass die Grundbausteine auf allen Plattformen gut ausssehen. Persönlich bin ich von Framework 7 begeistert.</p><ul><li><a href="https://framework7.io/">Framework 7</a></li><li>semantic UI</li><li>Material.io</li><li>Bootstrap</li></ul><h2>Datenhaltung</h2><p>Im backend unserer Anwendung mössen Daten gespeichert werden. Es gibt viele verschiedene Möglichkeiten, wie das geschehen kann. Es kommt auch drauf an, um was es geht. Beisspielsweise könnten Garten-spezifische Konfigurationen in einer YAMl oder JSON Datei auf dem Server gespeichert werden, der Rest in einer Mongo-Datenbank. Die Pflanzinformationen wiederum könnten in einer RDF-Datenbank gespeichert werden. Auch SQL (Postgres, MariaDB) wäre denkbar. Wichtig wäre bei einem Prototyp die einfache Anpassbarkeit und Erweiterbarkeit und dass das Datenbankformat bereits in einem günstigen Format um besispielsweise für das Frontend (zb. per Graph-QL) ausgeliefert werden kann. Sollten wir uns für Meteor entscheiden ist Mongo-DB betreits festgelegt.</p><ul><li>Mongo DB</li><li>RDF / Graphdatenbank</li><li>Filebasierend</li><li><a href="https://grandstack.io/">Neo4j + graphQL</a></li></ul><h2>Statemanagement</h2><p>Das Statemanagement ist entscheidend für die Erweiterbarkeit und die langfristige Wartbarkeit einer Anwendung. Hier entstehen auch die meisten Fehler. Redux, verursacht zwar ein wenig mehr Aufwand, da man viel &quot;Boilerplate&quot; schreiben muss, erleichtert aber das Debugging und die Wartbarkeit ungemein, da man jede Zustandsänderung global zurückverfolgen kann.</p><ul><li>redux</li><li>react</li><li>react-hooks</li><li>meteor</li><li>Apollo</li></ul><h2>backend-Frontend Kommunikation</h2><p>An verschiedenen Stellen des Programms kann es unterschiedliche Anforderungen geben. Wir müssen an dieser Stelle abwägen und uns gedanken machen an welchen Stellen wir eine sofortige Aktualisierung aller Clients wünschen (zum Beispiel bei der gemeinsamen Bearbeitung der Gartenkarte) und an welchen Stellen wir eher eine Offline Funktionalität wünschen. Es ist schwierig aber nicht unmöglich beides zu erreichen. Vielleicht nehmen wir deshalb auch unterschiedliche Ansätze.</p><ul><li>GraphQL</li><li>Pub-Sub</li><li>meteor/mini-mongo</li><li></li></ul><h2>Programmiersprache</h2><p>Es bietet sich an die gleiche Sprache für Front und Backend zu verwenden. Muss aber nicht. Der Vorteil ist dass man Code in Backend und Frontend gleichermaßen verwenden kann, dass man eventuelle Specs und Type-definitionen nur einemal schreiben muss und, dass ein_e Entwickler_in, die sich in einer SPrache besonder wohl fühlt besser Front und Backend gleichermaßen entwickeln kann.</p><ul><li>Clojure / ClojureScript</li><li>JavaScript</li><li><strong>TypeScript</strong></li><li>PHP</li></ul><h2>Build-Pipeline</h2><ul><li>Backend<ul><li>backpack</li><li>codegen (graphql -&gt; typescript)</li></ul></li><li>Frontend<ul><li>babel + ts</li><li>webpack<ul><li><a href="https://github.com/dotansimha/graphql-code-generator#readme">codegen</a> (graphql -&gt; typescript)</li><li></li></ul></li><li>pre-commit hook -&gt; husky -&gt; eslint --fix<ul><li>prettify</li></ul></li><li>cordova-cli<ul><li>android</li><li>electron</li><li>iOS</li></ul></li><li></li></ul></li></ul><h2>CI/CD</h2><ul><li><a href="https://circleci.com/">Circle CI</a></li><li>[HQ] ?</li></ul><h3>Workflows</h3><ul><li>test</li><li>puppeteer</li><li>build-web</li><li>build-cordova<ul><li>android</li><li>android+test</li></ul></li></ul><h2>spezial Bibliothek</h2><p>Für verschiedene Teilaufgaben brauchen wir &quot;Spezial&quot;-Bibliotheken.</p><ul><li><p>openlayers / leaflet -&gt; Gartenkarte</p></li><li><p>OAuth</p></li><li><p>Apollo Client+Server (graphQL)</p><ul><li>neo4j-driver</li></ul></li></ul><h2>Experimente</h2><p>https://codimd.gra.one/tBUxcSawQO-T-xILFxdYIg#</p></div></div></div></div><div class="ui text container"><div class="ui centered divided two column grid"><div class="row"><div class="column"><a target="_blank" href="/https://www.bmbf.de/en/index.html"><img class="footerImage" src="/BMBF-sponsered-by_de.jpg"/></a></div><div class="column"><a target="_blank" href="/https://prototypefund.de/en"><img class="footerImage" src="https://raw.githubusercontent.com/wiki/community-garden/community-garden.github.io/images/PrototypeFund-P-Logo.png"/></a></div></div></div></div></div><div class="fresnel-container fresnel-at-mobile "><div class="pushable"><div class="ui inverted vertical ui overlay left sidebar menu"><a class="item" href="/">Project</a><a class="item" href="/blog">Blog</a><a class="item" href="/milestones">Milestones</a><a class="item" href="/team">Team</a></div><div class="pusher"><div style="background-image:url(&quot;/jtilsch_06_2021_garden_q60.JPG&quot;);background-size:cover;background-position:top center;padding:1rem 0 2rem" class="ui inverted vertical center aligned segment"><div class="ui container"><div class="ui large inverted pointing secondary menu"><a class="item"><i aria-hidden="true" class="sidebar icon"></i></a><div class="right item"></div></div></div><div class="ui text container"><h1 style="font-size:3rem;font-weight:normal;margin-bottom:0;margin-top:1.5rem" class="ui inverted header">Community Garden App</h1><h2 style="font-size:1.5rem;font-weight:normal;margin-top:.5rem" class="ui inverted header">organize, manage, connect to local gardening initiatives</h2><button style="display:none" class="ui huge primary button">Get the App<i aria-hidden="true" class="right arrow icon"></i></button></div></div><div style="padding:4rem 0" class="ui vertical segment"><div class="ui text container"><div style="outline:none" tabindex="-1"><div class="blog"><a href="/blog/">&lt;<!-- --> Back</a><br/><h2>Frameworks &amp; Technologien</h2><h2>Platform</h2><ul><li>Desktop Browser (Fireforx + Chrome + Safari)</li><li>Desktop Electron (Cordov mit WebKit)</li><li>Desktop PWA (Firefox + Chrome)</li><li>mobil (iOS + Android) PWA (Firefox + Chrome)</li><li>mobil (iOS + Android)  almost nativ (Cordova mit WebKit)</li></ul><h2>Full-Stack</h2><p>Als Full-Stack bezeichnet man Frameworks, die einem ein fertigen Rahmen für die Client- und Serverentwicklung geben. Es ist nicht unbedingt notwendig ein FullStck Framework zu verwenden aber es kann mitunter die inertiale Entwicklung beschleunigen.</p><ul><li><a href="http://vulcanjs.org/">Vulcan.js</a></li><li><a href="https://www.meteor.com">Meteor</a></li><li><a href="https://fulcro.fulcrologic.com">Fulcro</a></li><li><a href="https://grandstack.io/">GRANDStack</a> - Neo4J, GraphQL, React, Apollo</li></ul><h2>UI</h2><p>Generell bietet es sich an ein modernes UI-Framework zu verwenden. Man profitiert von vielen bereits vorhandnenen Komponenten und kann außerdem auf bewährte Design-patterns (nicht Design im Sinn von Ausssehen sondern im Sinne der Strukturierung von Code) zurückgreifen. Im Web und App-Entwicklungsuniversum haben sich das funktionale Komponentenbasierte React-Framework bewährt, alternativen dazu wären Angular.JS oder WebComponents. Es gibt auch die Möglichkeit Platform native Komponenten zu nutzen, das schließt dann aber die Entwicklung von gleichzeitig einer Web-Anwendung aus. Auch die Platform-Übergreifende Entwicklung ist dann nicht möglich.</p><ul><li>React</li><li>React-Native</li><li>Reframe</li></ul><h4>UI Komponenten Sammlung</h4><p>Neben der UI-Technologie gibt es noch die eigentlichen fertigen Komponenten
auf die man um eines einheitlichen und komfortablen Designs wegen zurückgreifen
kann. Wir ersparen uns dadurch nicht nur arbeit, es ist dann auch gewährleistet, dass die Grundbausteine auf allen Plattformen gut ausssehen. Persönlich bin ich von Framework 7 begeistert.</p><ul><li><a href="https://framework7.io/">Framework 7</a></li><li>semantic UI</li><li>Material.io</li><li>Bootstrap</li></ul><h2>Datenhaltung</h2><p>Im backend unserer Anwendung mössen Daten gespeichert werden. Es gibt viele verschiedene Möglichkeiten, wie das geschehen kann. Es kommt auch drauf an, um was es geht. Beisspielsweise könnten Garten-spezifische Konfigurationen in einer YAMl oder JSON Datei auf dem Server gespeichert werden, der Rest in einer Mongo-Datenbank. Die Pflanzinformationen wiederum könnten in einer RDF-Datenbank gespeichert werden. Auch SQL (Postgres, MariaDB) wäre denkbar. Wichtig wäre bei einem Prototyp die einfache Anpassbarkeit und Erweiterbarkeit und dass das Datenbankformat bereits in einem günstigen Format um besispielsweise für das Frontend (zb. per Graph-QL) ausgeliefert werden kann. Sollten wir uns für Meteor entscheiden ist Mongo-DB betreits festgelegt.</p><ul><li>Mongo DB</li><li>RDF / Graphdatenbank</li><li>Filebasierend</li><li><a href="https://grandstack.io/">Neo4j + graphQL</a></li></ul><h2>Statemanagement</h2><p>Das Statemanagement ist entscheidend für die Erweiterbarkeit und die langfristige Wartbarkeit einer Anwendung. Hier entstehen auch die meisten Fehler. Redux, verursacht zwar ein wenig mehr Aufwand, da man viel &quot;Boilerplate&quot; schreiben muss, erleichtert aber das Debugging und die Wartbarkeit ungemein, da man jede Zustandsänderung global zurückverfolgen kann.</p><ul><li>redux</li><li>react</li><li>react-hooks</li><li>meteor</li><li>Apollo</li></ul><h2>backend-Frontend Kommunikation</h2><p>An verschiedenen Stellen des Programms kann es unterschiedliche Anforderungen geben. Wir müssen an dieser Stelle abwägen und uns gedanken machen an welchen Stellen wir eine sofortige Aktualisierung aller Clients wünschen (zum Beispiel bei der gemeinsamen Bearbeitung der Gartenkarte) und an welchen Stellen wir eher eine Offline Funktionalität wünschen. Es ist schwierig aber nicht unmöglich beides zu erreichen. Vielleicht nehmen wir deshalb auch unterschiedliche Ansätze.</p><ul><li>GraphQL</li><li>Pub-Sub</li><li>meteor/mini-mongo</li><li></li></ul><h2>Programmiersprache</h2><p>Es bietet sich an die gleiche Sprache für Front und Backend zu verwenden. Muss aber nicht. Der Vorteil ist dass man Code in Backend und Frontend gleichermaßen verwenden kann, dass man eventuelle Specs und Type-definitionen nur einemal schreiben muss und, dass ein_e Entwickler_in, die sich in einer SPrache besonder wohl fühlt besser Front und Backend gleichermaßen entwickeln kann.</p><ul><li>Clojure / ClojureScript</li><li>JavaScript</li><li><strong>TypeScript</strong></li><li>PHP</li></ul><h2>Build-Pipeline</h2><ul><li>Backend<ul><li>backpack</li><li>codegen (graphql -&gt; typescript)</li></ul></li><li>Frontend<ul><li>babel + ts</li><li>webpack<ul><li><a href="https://github.com/dotansimha/graphql-code-generator#readme">codegen</a> (graphql -&gt; typescript)</li><li></li></ul></li><li>pre-commit hook -&gt; husky -&gt; eslint --fix<ul><li>prettify</li></ul></li><li>cordova-cli<ul><li>android</li><li>electron</li><li>iOS</li></ul></li><li></li></ul></li></ul><h2>CI/CD</h2><ul><li><a href="https://circleci.com/">Circle CI</a></li><li>[HQ] ?</li></ul><h3>Workflows</h3><ul><li>test</li><li>puppeteer</li><li>build-web</li><li>build-cordova<ul><li>android</li><li>android+test</li></ul></li></ul><h2>spezial Bibliothek</h2><p>Für verschiedene Teilaufgaben brauchen wir &quot;Spezial&quot;-Bibliotheken.</p><ul><li><p>openlayers / leaflet -&gt; Gartenkarte</p></li><li><p>OAuth</p></li><li><p>Apollo Client+Server (graphQL)</p><ul><li>neo4j-driver</li></ul></li></ul><h2>Experimente</h2><p>https://codimd.gra.one/tBUxcSawQO-T-xILFxdYIg#</p></div></div></div></div></div></div></div></div></div><script type="text/javascript">window.__routeInfo = JSON.parse("{\"template\":\"__react_static_root__/src/containers/Post\",\"sharedHashesByProp\":{},\"data\":{\"post\":{\"basename\":\"(DE)-Tech-Stack.md\",\"title\":\"DE)-Tech-Stack\",\"id\":-2009237593,\"body\":\"## Frameworks & Technologien\\n\\n\\nPlatform\\n--\\n\\n- Desktop Browser (Fireforx + Chrome + Safari)\\n- Desktop Electron (Cordov mit WebKit)\\n- Desktop PWA (Firefox + Chrome)\\n- mobil (iOS + Android) PWA (Firefox + Chrome)\\n- mobil (iOS + Android)  almost nativ (Cordova mit WebKit)\\n\\nFull-Stack\\n--\\n\\nAls Full-Stack bezeichnet man Frameworks, die einem ein fertigen Rahmen f\u00FCr die Client- und Serverentwicklung geben. Es ist nicht unbedingt notwendig ein FullStck Framework zu verwenden aber es kann mitunter die inertiale Entwicklung beschleunigen.\\n\\n- [Vulcan.js](http://vulcanjs.org/)\\n- [Meteor](https://www.meteor.com)\\n- [Fulcro](https://fulcro.fulcrologic.com)\\n- [GRANDStack](https://grandstack.io/) - Neo4J, GraphQL, React, Apollo\\n\\n\\nUI\\n--\\n\\nGenerell bietet es sich an ein modernes UI-Framework zu verwenden. Man profitiert von vielen bereits vorhandnenen Komponenten und kann au\u00DFerdem auf bew\u00E4hrte Design-patterns (nicht Design im Sinn von Ausssehen sondern im Sinne der Strukturierung von Code) zur\u00FCckgreifen. Im Web und App-Entwicklungsuniversum haben sich das funktionale Komponentenbasierte React-Framework bew\u00E4hrt, alternativen dazu w\u00E4ren Angular.JS oder WebComponents. Es gibt auch die M\u00F6glichkeit Platform native Komponenten zu nutzen, das schlie\u00DFt dann aber die Entwicklung von gleichzeitig einer Web-Anwendung aus. Auch die Platform-\u00DCbergreifende Entwicklung ist dann nicht m\u00F6glich. \\n\\n- React\\n- React-Native\\n- Reframe\\n\\n\\n#### UI Komponenten Sammlung\\n\\nNeben der UI-Technologie gibt es noch die eigentlichen fertigen Komponenten\\nauf die man um eines einheitlichen und komfortablen Designs wegen zur\u00FCckgreifen\\nkann. Wir ersparen uns dadurch nicht nur arbeit, es ist dann auch gew\u00E4hrleistet, dass die Grundbausteine auf allen Plattformen gut ausssehen. Pers\u00F6nlich bin ich von Framework 7 begeistert.\\n\\n- [Framework 7](https://framework7.io/)\\n- semantic UI\\n- Material.io\\n- Bootstrap\\n\\n\\nDatenhaltung\\n--\\n\\nIm backend unserer Anwendung m\u00F6ssen Daten gespeichert werden. Es gibt viele verschiedene M\u00F6glichkeiten, wie das geschehen kann. Es kommt auch drauf an, um was es geht. Beisspielsweise k\u00F6nnten Garten-spezifische Konfigurationen in einer YAMl oder JSON Datei auf dem Server gespeichert werden, der Rest in einer Mongo-Datenbank. Die Pflanzinformationen wiederum k\u00F6nnten in einer RDF-Datenbank gespeichert werden. Auch SQL (Postgres, MariaDB) w\u00E4re denkbar. Wichtig w\u00E4re bei einem Prototyp die einfache Anpassbarkeit und Erweiterbarkeit und dass das Datenbankformat bereits in einem g\u00FCnstigen Format um besispielsweise f\u00FCr das Frontend (zb. per Graph-QL) ausgeliefert werden kann. Sollten wir uns f\u00FCr Meteor entscheiden ist Mongo-DB betreits festgelegt.\\n\\n- Mongo DB\\n- RDF / Graphdatenbank\\n- Filebasierend\\n- [Neo4j + graphQL](https://grandstack.io/)\\n\\n\\nStatemanagement\\n--\\n\\nDas Statemanagement ist entscheidend f\u00FCr die Erweiterbarkeit und die langfristige Wartbarkeit einer Anwendung. Hier entstehen auch die meisten Fehler. Redux, verursacht zwar ein wenig mehr Aufwand, da man viel \\\"Boilerplate\\\" schreiben muss, erleichtert aber das Debugging und die Wartbarkeit ungemein, da man jede Zustands\u00E4nderung global zur\u00FCckverfolgen kann. \\n\\n- redux\\n- react\\n- react-hooks\\n- meteor\\n- Apollo\\n\\n\\nbackend-Frontend Kommunikation\\n--\\n\\nAn verschiedenen Stellen des Programms kann es unterschiedliche Anforderungen geben. Wir m\u00FCssen an dieser Stelle abw\u00E4gen und uns gedanken machen an welchen Stellen wir eine sofortige Aktualisierung aller Clients w\u00FCnschen (zum Beispiel bei der gemeinsamen Bearbeitung der Gartenkarte) und an welchen Stellen wir eher eine Offline Funktionalit\u00E4t w\u00FCnschen. Es ist schwierig aber nicht unm\u00F6glich beides zu erreichen. Vielleicht nehmen wir deshalb auch unterschiedliche Ans\u00E4tze.\\n\\n- GraphQL\\n- Pub-Sub\\n- meteor/mini-mongo\\n- \\n\\n\\nProgrammiersprache\\n---\\n\\nEs bietet sich an die gleiche Sprache f\u00FCr Front und Backend zu verwenden. Muss aber nicht. Der Vorteil ist dass man Code in Backend und Frontend gleicherma\u00DFen verwenden kann, dass man eventuelle Specs und Type-definitionen nur einemal schreiben muss und, dass ein_e Entwickler_in, die sich in einer SPrache besonder wohl f\u00FChlt besser Front und Backend gleicherma\u00DFen entwickeln kann.\\n\\n- Clojure / ClojureScript\\n- JavaScript\\n- **TypeScript**\\n- PHP\\n\\nBuild-Pipeline\\n--\\n \\n - Backend\\n     - backpack\\n     - codegen (graphql -> typescript)\\n \\n - Frontend\\n     - babel + ts\\n     - webpack\\n         - [codegen](https://github.com/dotansimha/graphql-code-generator#readme) (graphql -> typescript)\\n         -\\n     - pre-commit hook -> husky -> eslint --fix\\n         - prettify\\n     - cordova-cli\\n         - android\\n         - electron\\n         - iOS\\n    - \\n\\n\\nCI/CD\\n--\\n\\n- [Circle CI](https://circleci.com/)\\n- [HQ] ?\\n\\n### Workflows\\n\\n- test\\n- puppeteer\\n- build-web\\n- build-cordova\\n    - android\\n    - android+test\\n\\n\\nspezial Bibliothek\\n--\\n\\nF\u00FCr verschiedene Teilaufgaben brauchen wir \\\"Spezial\\\"-Bibliotheken.\\n\\n\\n- openlayers / leaflet -> Gartenkarte\\n- OAuth\\n\\n- Apollo Client+Server (graphQL)\\n    - neo4j-driver\\n\\nExperimente\\n---\\n\\nhttps://codimd.gra.one/tBUxcSawQO-T-xILFxdYIg#\\n\\n\"}},\"path\":\"blog/post/-2009237593\",\"sharedData\":{},\"siteData\":{}}");</script><script defer="" type="text/javascript" src="/templates/vendors~__react_static_root__/src/containers/Markdown~__react_static_root__/src/containers/Post~__re~b073af23.45cfb8c8.js"></script><script defer="" type="text/javascript" src="/templates/__react_static_root__/src/containers/Post.295a4ca4.js"></script><script defer="" type="text/javascript" src="/templates/styles.76a77108.js"></script><script defer="" type="text/javascript" src="/templates/vendors~main.4c21852a.js"></script><script defer="" type="text/javascript" src="/main.2c295d01.js"></script></body></html>