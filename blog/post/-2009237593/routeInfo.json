{"template":"__react_static_root__/src/containers/Post","sharedHashesByProp":{},"data":{"post":{"basename":"(DE)-Tech-Stack.md","title":"DE)-Tech-Stack","id":-2009237593,"body":"## Frameworks & Technologien\n\n\nPlatform\n--\n\n- Desktop Browser (Fireforx + Chrome + Safari)\n- Desktop Electron (Cordov mit WebKit)\n- Desktop PWA (Firefox + Chrome)\n- mobil (iOS + Android) PWA (Firefox + Chrome)\n- mobil (iOS + Android)  almost nativ (Cordova mit WebKit)\n\nFull-Stack\n--\n\nAls Full-Stack bezeichnet man Frameworks, die einem ein fertigen Rahmen für die Client- und Serverentwicklung geben. Es ist nicht unbedingt notwendig ein FullStck Framework zu verwenden aber es kann mitunter die inertiale Entwicklung beschleunigen.\n\n- [Vulcan.js](http://vulcanjs.org/)\n- [Meteor](https://www.meteor.com)\n- [Fulcro](https://fulcro.fulcrologic.com)\n- [GRANDStack](https://grandstack.io/) - Neo4J, GraphQL, React, Apollo\n\n\nUI\n--\n\nGenerell bietet es sich an ein modernes UI-Framework zu verwenden. Man profitiert von vielen bereits vorhandnenen Komponenten und kann außerdem auf bewährte Design-patterns (nicht Design im Sinn von Ausssehen sondern im Sinne der Strukturierung von Code) zurückgreifen. Im Web und App-Entwicklungsuniversum haben sich das funktionale Komponentenbasierte React-Framework bewährt, alternativen dazu wären Angular.JS oder WebComponents. Es gibt auch die Möglichkeit Platform native Komponenten zu nutzen, das schließt dann aber die Entwicklung von gleichzeitig einer Web-Anwendung aus. Auch die Platform-Übergreifende Entwicklung ist dann nicht möglich. \n\n- React\n- React-Native\n- Reframe\n\n\n#### UI Komponenten Sammlung\n\nNeben der UI-Technologie gibt es noch die eigentlichen fertigen Komponenten\nauf die man um eines einheitlichen und komfortablen Designs wegen zurückgreifen\nkann. Wir ersparen uns dadurch nicht nur arbeit, es ist dann auch gewährleistet, dass die Grundbausteine auf allen Plattformen gut ausssehen. Persönlich bin ich von Framework 7 begeistert.\n\n- [Framework 7](https://framework7.io/)\n- semantic UI\n- Material.io\n- Bootstrap\n\n\nDatenhaltung\n--\n\nIm backend unserer Anwendung mössen Daten gespeichert werden. Es gibt viele verschiedene Möglichkeiten, wie das geschehen kann. Es kommt auch drauf an, um was es geht. Beisspielsweise könnten Garten-spezifische Konfigurationen in einer YAMl oder JSON Datei auf dem Server gespeichert werden, der Rest in einer Mongo-Datenbank. Die Pflanzinformationen wiederum könnten in einer RDF-Datenbank gespeichert werden. Auch SQL (Postgres, MariaDB) wäre denkbar. Wichtig wäre bei einem Prototyp die einfache Anpassbarkeit und Erweiterbarkeit und dass das Datenbankformat bereits in einem günstigen Format um besispielsweise für das Frontend (zb. per Graph-QL) ausgeliefert werden kann. Sollten wir uns für Meteor entscheiden ist Mongo-DB betreits festgelegt.\n\n- Mongo DB\n- RDF / Graphdatenbank\n- Filebasierend\n- [Neo4j + graphQL](https://grandstack.io/)\n\n\nStatemanagement\n--\n\nDas Statemanagement ist entscheidend für die Erweiterbarkeit und die langfristige Wartbarkeit einer Anwendung. Hier entstehen auch die meisten Fehler. Redux, verursacht zwar ein wenig mehr Aufwand, da man viel \"Boilerplate\" schreiben muss, erleichtert aber das Debugging und die Wartbarkeit ungemein, da man jede Zustandsänderung global zurückverfolgen kann. \n\n- redux\n- react\n- react-hooks\n- meteor\n- Apollo\n\n\nbackend-Frontend Kommunikation\n--\n\nAn verschiedenen Stellen des Programms kann es unterschiedliche Anforderungen geben. Wir müssen an dieser Stelle abwägen und uns gedanken machen an welchen Stellen wir eine sofortige Aktualisierung aller Clients wünschen (zum Beispiel bei der gemeinsamen Bearbeitung der Gartenkarte) und an welchen Stellen wir eher eine Offline Funktionalität wünschen. Es ist schwierig aber nicht unmöglich beides zu erreichen. Vielleicht nehmen wir deshalb auch unterschiedliche Ansätze.\n\n- GraphQL\n- Pub-Sub\n- meteor/mini-mongo\n- \n\n\nProgrammiersprache\n---\n\nEs bietet sich an die gleiche Sprache für Front und Backend zu verwenden. Muss aber nicht. Der Vorteil ist dass man Code in Backend und Frontend gleichermaßen verwenden kann, dass man eventuelle Specs und Type-definitionen nur einemal schreiben muss und, dass ein_e Entwickler_in, die sich in einer SPrache besonder wohl fühlt besser Front und Backend gleichermaßen entwickeln kann.\n\n- Clojure / ClojureScript\n- JavaScript\n- **TypeScript**\n- PHP\n\nBuild-Pipeline\n--\n \n - Backend\n     - backpack\n     - codegen (graphql -> typescript)\n \n - Frontend\n     - babel + ts\n     - webpack\n         - [codegen](https://github.com/dotansimha/graphql-code-generator#readme) (graphql -> typescript)\n         -\n     - pre-commit hook -> husky -> eslint --fix\n         - prettify\n     - cordova-cli\n         - android\n         - electron\n         - iOS\n    - \n\n\nCI/CD\n--\n\n- [Circle CI](https://circleci.com/)\n- [HQ] ?\n\n### Workflows\n\n- test\n- puppeteer\n- build-web\n- build-cordova\n    - android\n    - android+test\n\n\nspezial Bibliothek\n--\n\nFür verschiedene Teilaufgaben brauchen wir \"Spezial\"-Bibliotheken.\n\n\n- openlayers / leaflet -> Gartenkarte\n- OAuth\n\n- Apollo Client+Server (graphQL)\n    - neo4j-driver\n\nExperimente\n---\n\nhttps://codimd.gra.one/tBUxcSawQO-T-xILFxdYIg#\n\n"}},"path":"blog/post/-2009237593"}
